"""
GitHub APIé–¢é€£ã®é–¢æ•°
"""

import json
import re
from typing import Dict, Any, List, Tuple

from github import Github
from github.GithubException import GithubException

from version_utils import version_in_range, compare_versions
import markers


def get_pr_details(repo: str, pr_number: int, github_token: str) -> Dict[str, Any]:
    """GitHub APIã‹ã‚‰PRè©³ç´°ã‚’å–å¾—"""
    g = Github(github_token)
    repository = g.get_repo(repo)
    pr = repository.get_pull(pr_number)

    return {
        'number': pr.number,
        'title': pr.title,
        'body': pr.body or '',
        'state': pr.state,
        'html_url': pr.html_url,
        'user': {'login': pr.user.login} if pr.user else None,
    }


def extract_cve_numbers(pr_body: str) -> List[str]:
    """PRæœ¬æ–‡ã‹ã‚‰CVEç•ªå·ã‚’æŠ½å‡º"""
    cve_pattern = r'CVE-\d{4}-\d+'
    cves = re.findall(cve_pattern, pr_body, re.IGNORECASE)
    return list(set(cves))  # é‡è¤‡ã‚’é™¤å»

def normalize_package_name(name: str, ecosystem: str) -> str:
    # same as renovate's normalizePackageName
    # https://github.com/renovatebot/renovate/blob/930cf6633ccf38f3578cb112c7ad42c7f99e1cdb/lib/modules/platform/utils/github-alerts.ts
    if ecosystem == "pip":
        return re.sub(r"[-_.]+", "-", name).lower()
    return name

def find_cves_by_package_and_version(
    repo: str,
    package_name: str,
    from_version: str,
    to_version: str,
    github_token: str
) -> List[Tuple[str, int, str]]:
    """ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åã¨ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‹ã‚‰ã“ã®PRã§ä¿®æ­£ã•ã‚Œã‚‹CVEç•ªå·ã‚’å–å¾—

    Args:
        repo: ãƒªãƒã‚¸ãƒˆãƒªåï¼ˆowner/repoå½¢å¼ï¼‰
        package_name: ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸å (ä¾‹: "lodash")
        from_version: ç¾åœ¨ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ (ä¾‹: "4.17.20")
        to_version: ä¿®æ­£å…ˆã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ (ä¾‹: "4.17.21")
        github_token: GitHub ãƒˆãƒ¼ã‚¯ãƒ³

    Returns:
        ã“ã®PRã§ä¿®æ­£ã•ã‚Œã‚‹CVEæƒ…å ±ã®ãƒªã‚¹ãƒˆ [(cve_id, alert_number, alert_url), ...]
    """
    try:
        print(f"ğŸ” ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ '{package_name}' (v{from_version} â†’ v{to_version}) ã®CVEç•ªå·ã‚’æ¤œç´¢ä¸­...")
        print(f"   ãƒªãƒã‚¸ãƒˆãƒª: {repo}")

        g = Github(github_token)
        repository = g.get_repo(repo)

        # Dependabotã‚¢ãƒ©ãƒ¼ãƒˆã‚’å–å¾—
        alerts = repository.get_dependabot_alerts(state='open')
        matching_cves = []
        for alert in alerts:
            vuln = alert.security_vulnerability
            # ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åã§ãƒ•ã‚£ãƒ«ã‚¿
            if normalize_package_name(vuln.package.name, vuln.package.ecosystem) != normalize_package_name(package_name, vuln.package.ecosystem):
                continue
            
            # from_versionãŒè„†å¼±ãªãƒãƒ¼ã‚¸ãƒ§ãƒ³ã§ã‚ã‚‹ã‹ã®ãƒã‚§ãƒƒã‚¯
            if not version_in_range(from_version, vuln.vulnerable_version_range):
                continue

            # to_versionãŒä¿®æ­£æ¸ˆã¿ãƒãƒ¼ã‚¸ãƒ§ãƒ³ä»¥ä¸Šã§ã‚ã‚‹ã‹ã®ãƒã‚§ãƒƒã‚¯
            if compare_versions(to_version, vuln.first_patched_version["identifier"]) < 0:
                continue
            
            cve = alert.security_advisory.cve_id
            if not cve:
                continue
            cve_info = (cve, alert.number, alert.html_url)
            matching_cves.append(cve_info)

        print(f"   âœ… {len(matching_cves)} ä»¶ã®ã‚¢ãƒ©ãƒ¼ãƒˆã‚’å–å¾—")

        if matching_cves:
            cve_ids = [cve_id for cve_id, _, _ in matching_cves]
            print(f"âœ… {len(matching_cves)} ä»¶ã®CVEç•ªå·ã‚’å–å¾—: {', '.join(cve_ids)}")
        else:
            print(f"âš ï¸ ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ '{package_name}' v{from_version}â†’v{to_version} ã«ä¸€è‡´ã™ã‚‹CVEãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“")

        return matching_cves

    except GithubException as e:
        print(f"âš ï¸ Dependabotã‚¢ãƒ©ãƒ¼ãƒˆæ¤œç´¢ã‚¨ãƒ©ãƒ¼ (HTTP {e.status}): {e.data}")
        return []
    except Exception as e:
        print(f"âš ï¸ Dependabotã‚¢ãƒ©ãƒ¼ãƒˆæ¤œç´¢ã‚¨ãƒ©ãƒ¼: {e}")
        import traceback
        traceback.print_exc()
        return []


def get_previous_analysis(repo: str, pr_number: int, package_name: str, github_token: str) -> str:
    """åŒã˜PRã®éå»ã®vulnerability_analyzer.pyç”Ÿæˆã‚³ãƒ¡ãƒ³ãƒˆã‚’å–å¾—

    Args:
        repo: ãƒªãƒã‚¸ãƒˆãƒªåï¼ˆowner/repoå½¢å¼ï¼‰
        pr_number: PRç•ªå·
        package_name: ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åï¼ˆãã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã«é–¢ã™ã‚‹ã‚³ãƒ¡ãƒ³ãƒˆã®ã¿ã‚’å–å¾—ï¼‰
        github_token: GitHub ãƒˆãƒ¼ã‚¯ãƒ³

    Returns:
        å‰å›ã®åˆ†æçµæœï¼ˆè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ç©ºæ–‡å­—åˆ—ï¼‰
    """
    try:
        g = Github(github_token)
        repository = g.get_repo(repo)
        pr = repository.get_pull(pr_number)
        comments = list(pr.get_issue_comments())

        # vulnerability_analyzer.pyã«ã‚ˆã£ã¦ç”Ÿæˆã•ã‚ŒãŸã‚³ãƒ¡ãƒ³ãƒˆã‚’æ¢ã™
        for comment in reversed(comments):
            body = comment.body or ''
            if 'This comment was automatically generated by dependahunt.' in body:
                # ãƒãƒ¼ã‚«ãƒ¼ã‹ã‚‰ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸æƒ…å ±ã‚’æŠ½å‡º
                version_info = markers.ANALYZED_PACKAGE.extract(body)

                if not version_info:
                    continue  # ãƒãƒ¼ã‚«ãƒ¼ãŒãªã„ã‚³ãƒ¡ãƒ³ãƒˆã¯ã‚¹ã‚­ãƒƒãƒ—

                # ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸åãŒä¸€è‡´ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                if version_info.get('package') != package_name:
                    continue  # ã“ã®ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ã‚³ãƒ¡ãƒ³ãƒˆã§ã¯ãªã„ã®ã§ã‚¹ã‚­ãƒƒãƒ—

                # è©³ç´°åˆ†æçµæœã‚»ã‚¯ã‚·ãƒ§ãƒ³ã‚’æŠ½å‡º
                # çµè«–éƒ¨åˆ†ã¨è©³ç´°åˆ†æéƒ¨åˆ†ã‚’åˆ†é›¢
                match = re.search(r'## ğŸ”’ è©³ç´°åˆ†æçµæœ.*?(?=## ğŸ“‹ CVEåŸºæœ¬æƒ…å ±|\Z)', body, re.DOTALL)
                if match:
                    return match.group(0).strip()

                # ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å…¨ä½“ã‚’è¿”ã™
                return body

        return ""

    except Exception as e:
        print(f"âš ï¸ å‰å›åˆ†æã®å–å¾—ã«å¤±æ•—: {e}")
        return ""


def mark_pr_as_analyzed(repo: str, pr_number: int, github_token: str) -> bool:
    """PRæœ¬æ–‡ã«ãƒãƒ¼ã‚«ãƒ¼ã‚’è¿½è¨˜

    Args:
        repo: ãƒªãƒã‚¸ãƒˆãƒªå (owner/repoå½¢å¼)
        pr_number: PRç•ªå·
        github_token: GitHub ãƒˆãƒ¼ã‚¯ãƒ³

    Returns:
        è¿½è¨˜ã«æˆåŠŸã—ãŸå ´åˆTrue
    """
    try:
        g = Github(github_token)
        repository = g.get_repo(repo)
        pr = repository.get_pull(pr_number)
        pr_body = pr.body or ''

        # æ—¢ã«è¿½è¨˜æ¸ˆã¿ã‹ãƒã‚§ãƒƒã‚¯
        if markers.ANALYZED.exists_in(pr_body):
            print("â„¹ï¸ ãƒãƒ¼ã‚«ãƒ¼ã¯æ—¢ã«PRæœ¬æ–‡ã«è¿½è¨˜æ¸ˆã¿ã§ã™")
            return True

        print("ğŸ“ PRæœ¬æ–‡ã«ãƒãƒ¼ã‚«ãƒ¼ã‚’è¿½è¨˜ä¸­...")
        # ãƒãƒ¼ã‚«ãƒ¼ã ã‘è¿½åŠ ã—ã¦é‡è¤‡å®Ÿè¡Œã‚’é˜²æ­¢
        new_body = pr_body + f"\n\n{markers.ANALYZED.create()}\n"
        pr.edit(body=new_body)
        print(f"âœ… PRæœ¬æ–‡ã‚’æ›´æ–°ã—ã¾ã—ãŸ")
        return True

    except Exception as e:
        print(f"âŒ PRæœ¬æ–‡æ›´æ–°ã‚¨ãƒ©ãƒ¼: {e}")
        return False


def post_github_comment(repo: str, pr_number: int, comment: str, github_token: str) -> bool:
    """GitHub APIã‚’ä½¿ã£ã¦PRã«ã‚³ãƒ¡ãƒ³ãƒˆã‚’æŠ•ç¨¿"""
    try:
        g = Github(github_token)
        repository = g.get_repo(repo)
        pr = repository.get_pull(pr_number)
        created_comment = pr.create_issue_comment(comment)
        print(f"âœ… ã‚³ãƒ¡ãƒ³ãƒˆã‚’æŠ•ç¨¿ã—ã¾ã—ãŸ: {created_comment.html_url}")
        return True

    except GithubException as e:
        print(f"âŒ GitHub APIã‚¨ãƒ©ãƒ¼: {e}")
        return False
    except Exception as e:
        print(f"âŒ ã‚³ãƒ¡ãƒ³ãƒˆæŠ•ç¨¿ã‚¨ãƒ©ãƒ¼: {e}")
        return False
